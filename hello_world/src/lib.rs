use tari_template_macros::template;

#[template]
mod hello_world {
    // Not sure if deriving a trait like this would be compatible with our template macro
    #[derive(Default)]
    struct HelloWorld {}

    impl HelloWorld {
        pub fn greet() -> String {
            "Hello World!".to_string()
        }
    }
}

#[cfg(test)]
mod tests {
    
    // by default it assumes that the test is in the same Rust project as the template
    // if the template we want to test is in another project, we coould specify:
    //     #[template_stub(path = "../another_poject", module="HelloWorld")]
    #[template_stub(module="HelloWorld")]
    struct HelloWorld;

    // the "template_test" macro ensures that all instructions inside the test code will be executed atomically as a single transaction
    #[template_test]
    fn greet_works() {
        // initialize the component
        let mut hello_world = HelloWorld::default();

        // the "HelloWorld" struct referenced in this test is a wrapper generated by the "template_stub" macro
        // so it will implement a "Component" trait with utility functions like "component_address()"
        println!("The component address is: {}", hello_world.component_address());

        // the "template_stub" macro generates a proxy function for each user-defined function in the template,
        // internally it builds and runs a transaction on the wasm engine for each function/method invocation
        assert_eq!(hello_world.greet(), Ok("Hello World!".to_string()));
    }

    // This is how the test would be written without the "template_test" macro
    // Useful to highligth that the stubs can be used outside of testing, in real environments
    #[test]
    fn greet_works_without_macro() {
        // outside of test we could use a "mainnet" runtime, or a "testnet" one
        // we could also configure which Validator Nodes we want to use, and the fees to pay for the transaction
        let runtime = TestRuntime::new();
        let transaction_builder = TransactionBuilder::new(runtime);

        // this is equivalent to the "greet_work" test
        // by specifying all the operations to run, the builder creates an atomic transaction
        // so we could manipulate "Bucket" variables inside the scope without problems
        transaction_builder.build(|| {
            let mut hello_world = HelloWorld::default();
            println!("The component address is: {}", hello_world.component_address());
            assert_eq!(hello_world.greet(), Ok("Hello World!".to_string()));
        })
        .execute();
    }
}
